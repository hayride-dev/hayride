use anyhow::Result;
use super::{Backend, Rag, ModelRepository};
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;
use wasmtime::component::ResourceTable;
pub struct AiCtx {
    // The output directory for the runtime.
    pub out_dir: Option<String>,

    pub backend: Backend,
    pub rag: Rag,

    pub model_repository: ModelRepository,

    // An optional model path to load models from
    pub model_path: Option<String>,
    thread_id: Arc<AtomicI32>,
}

impl AiCtx {
    pub fn new(out_dir: Option<String>, model_path: Option<String>) -> Result<Self> {
        #[cfg(not(feature = "llamacpp"))]
        let backend = Box::new(hayride_host_traits::ai::nn::mock::MockBackend::default());
        #[cfg(feature = "llamacpp")]
        let backend = Box::new(hayride_llama::LlamaCppBackend::new());

        #[cfg(not(feature = "lancedb"))]
        let rag = Box::new(hayride_host_traits::ai::rag::mock::MockRagInner::default());
        #[cfg(feature = "lancedb")]
        let rag = Box::new(hayride_lancedb::LanceDBRag::default());

        #[cfg(not(feature = "hf"))]
        let model_repository = Box::new(hayride_host_traits::ai::model::mock::MockModelLoaderInner::default());
        #[cfg(feature = "hf")]
        let model_repository = Box::new(hayride_hf::HuggingFaceModelRepository::new()?);

        let thread_id = Arc::new(AtomicI32::new(0));
        Ok(Self {
            out_dir,
            backend: Backend(backend),
            rag: Rag(rag),
            model_repository: ModelRepository(model_repository),
            model_path: model_path,
            thread_id,
        })
    }

    pub fn next_thread_id(&self) -> Option<i32> {
        match self
            .thread_id
            .fetch_update(Ordering::Relaxed, Ordering::Relaxed, |v| match v {
                ..=0x1ffffffe => Some(v + 1),
                _ => None,
            }) {
            Ok(v) => Some(v + 1),
            Err(_) => None,
        }
    }
}

pub trait AiView: Send {
    /// Returns a mutable reference to the ml context.
    fn ctx(&mut self) -> &mut AiCtx;

    /// Returns a mutable reference to the ml resource table.
    fn table(&mut self) -> &mut ResourceTable;
}

impl<T: ?Sized + AiView> AiView for &mut T {
    fn ctx(&mut self) -> &mut AiCtx {
        T::ctx(self)
    }

    fn table(&mut self) -> &mut ResourceTable {
        T::table(self)
    }
}

impl<T: ?Sized + AiView> AiView for Box<T> {
    fn ctx(&mut self) -> &mut AiCtx {
        T::ctx(self)
    }

    fn table(&mut self) -> &mut ResourceTable {
        T::table(self)
    }
}

/// A concrete structure that all generated `Host` traits are implemented for.
///
/// This type serves as a small newtype wrapper to implement all of the `Host`
/// traits for `hayride:spawn`. This type is internally used and is only needed if
/// you're interacting with `add_to_linker` functions generated by bindings
/// themselves (or `add_to_linker_get_host`).
///
/// This type is automatically used when using
/// [`add_to_linker_async`](crate::add_to_linker_async)
/// or
/// [`add_to_linker_sync`](crate::add_to_linker_sync)
/// and doesn't need to be manually configured.
#[repr(transparent)]
pub struct AiImpl<T>(pub T);

impl<T: AiView> AiView for AiImpl<T> {
    fn ctx(&mut self) -> &mut AiCtx {
        self.0.ctx()
    }

    fn table(&mut self) -> &mut ResourceTable {
        self.0.table()
    }
}
